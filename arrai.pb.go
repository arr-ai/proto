// Code generated by protoc-gen-go. DO NOT EDIT.
// source: arrai.proto

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	arrai.proto

It has these top-level messages:
	UpdateReq
	UpdateAck
	ObserveReq
	ObserveResp
	Value
	Number
	Tuple
	Set
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

type UpdateReq struct {
	Expr  string `protobuf:"bytes,1,opt,name=expr" json:"expr,omitempty"`
	Param *Value `protobuf:"bytes,2,opt,name=param" json:"param,omitempty"`
}

func (m *UpdateReq) Reset()                    { *m = UpdateReq{} }
func (m *UpdateReq) String() string            { return proto1.CompactTextString(m) }
func (*UpdateReq) ProtoMessage()               {}
func (*UpdateReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *UpdateReq) GetExpr() string {
	if m != nil {
		return m.Expr
	}
	return ""
}

func (m *UpdateReq) GetParam() *Value {
	if m != nil {
		return m.Param
	}
	return nil
}

type UpdateAck struct {
}

func (m *UpdateAck) Reset()                    { *m = UpdateAck{} }
func (m *UpdateAck) String() string            { return proto1.CompactTextString(m) }
func (*UpdateAck) ProtoMessage()               {}
func (*UpdateAck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type ObserveReq struct {
	Expr  string `protobuf:"bytes,1,opt,name=expr" json:"expr,omitempty"`
	Param *Value `protobuf:"bytes,2,opt,name=param" json:"param,omitempty"`
}

func (m *ObserveReq) Reset()                    { *m = ObserveReq{} }
func (m *ObserveReq) String() string            { return proto1.CompactTextString(m) }
func (*ObserveReq) ProtoMessage()               {}
func (*ObserveReq) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ObserveReq) GetExpr() string {
	if m != nil {
		return m.Expr
	}
	return ""
}

func (m *ObserveReq) GetParam() *Value {
	if m != nil {
		return m.Param
	}
	return nil
}

type ObserveResp struct {
	Value *Value `protobuf:"bytes,3,opt,name=value" json:"value,omitempty"`
}

func (m *ObserveResp) Reset()                    { *m = ObserveResp{} }
func (m *ObserveResp) String() string            { return proto1.CompactTextString(m) }
func (*ObserveResp) ProtoMessage()               {}
func (*ObserveResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ObserveResp) GetValue() *Value {
	if m != nil {
		return m.Value
	}
	return nil
}

type Value struct {
	// Types that are valid to be assigned to Choice:
	//	*Value_Number
	//	*Value_Tuple
	//	*Value_Set
	//	*Value_Json
	Choice isValue_Choice `protobuf_oneof:"choice"`
}

func (m *Value) Reset()                    { *m = Value{} }
func (m *Value) String() string            { return proto1.CompactTextString(m) }
func (*Value) ProtoMessage()               {}
func (*Value) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isValue_Choice interface {
	isValue_Choice()
}

type Value_Number struct {
	Number *Number `protobuf:"bytes,1,opt,name=number,oneof"`
}
type Value_Tuple struct {
	Tuple *Tuple `protobuf:"bytes,2,opt,name=tuple,oneof"`
}
type Value_Set struct {
	Set *Set `protobuf:"bytes,3,opt,name=set,oneof"`
}
type Value_Json struct {
	Json string `protobuf:"bytes,4,opt,name=json,oneof"`
}

func (*Value_Number) isValue_Choice() {}
func (*Value_Tuple) isValue_Choice()  {}
func (*Value_Set) isValue_Choice()    {}
func (*Value_Json) isValue_Choice()   {}

func (m *Value) GetChoice() isValue_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *Value) GetNumber() *Number {
	if x, ok := m.GetChoice().(*Value_Number); ok {
		return x.Number
	}
	return nil
}

func (m *Value) GetTuple() *Tuple {
	if x, ok := m.GetChoice().(*Value_Tuple); ok {
		return x.Tuple
	}
	return nil
}

func (m *Value) GetSet() *Set {
	if x, ok := m.GetChoice().(*Value_Set); ok {
		return x.Set
	}
	return nil
}

func (m *Value) GetJson() string {
	if x, ok := m.GetChoice().(*Value_Json); ok {
		return x.Json
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Value) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _Value_OneofMarshaler, _Value_OneofUnmarshaler, _Value_OneofSizer, []interface{}{
		(*Value_Number)(nil),
		(*Value_Tuple)(nil),
		(*Value_Set)(nil),
		(*Value_Json)(nil),
	}
}

func _Value_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*Value)
	// choice
	switch x := m.Choice.(type) {
	case *Value_Number:
		b.EncodeVarint(1<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Number); err != nil {
			return err
		}
	case *Value_Tuple:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Tuple); err != nil {
			return err
		}
	case *Value_Set:
		b.EncodeVarint(3<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Set); err != nil {
			return err
		}
	case *Value_Json:
		b.EncodeVarint(4<<3 | proto1.WireBytes)
		b.EncodeStringBytes(x.Json)
	case nil:
	default:
		return fmt.Errorf("Value.Choice has unexpected type %T", x)
	}
	return nil
}

func _Value_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*Value)
	switch tag {
	case 1: // choice.number
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Number)
		err := b.DecodeMessage(msg)
		m.Choice = &Value_Number{msg}
		return true, err
	case 2: // choice.tuple
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Tuple)
		err := b.DecodeMessage(msg)
		m.Choice = &Value_Tuple{msg}
		return true, err
	case 3: // choice.set
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Set)
		err := b.DecodeMessage(msg)
		m.Choice = &Value_Set{msg}
		return true, err
	case 4: // choice.json
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Choice = &Value_Json{x}
		return true, err
	default:
		return false, nil
	}
}

func _Value_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*Value)
	// choice
	switch x := m.Choice.(type) {
	case *Value_Number:
		s := proto1.Size(x.Number)
		n += proto1.SizeVarint(1<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_Tuple:
		s := proto1.Size(x.Tuple)
		n += proto1.SizeVarint(2<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_Set:
		s := proto1.Size(x.Set)
		n += proto1.SizeVarint(3<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Value_Json:
		n += proto1.SizeVarint(4<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(len(x.Json)))
		n += len(x.Json)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Number struct {
	// Types that are valid to be assigned to Repr:
	//	*Number_N
	Repr isNumber_Repr `protobuf_oneof:"repr"`
}

func (m *Number) Reset()                    { *m = Number{} }
func (m *Number) String() string            { return proto1.CompactTextString(m) }
func (*Number) ProtoMessage()               {}
func (*Number) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isNumber_Repr interface {
	isNumber_Repr()
}

type Number_N struct {
	N float64 `protobuf:"fixed64,1,opt,name=n,oneof"`
}

func (*Number_N) isNumber_Repr() {}

func (m *Number) GetRepr() isNumber_Repr {
	if m != nil {
		return m.Repr
	}
	return nil
}

func (m *Number) GetN() float64 {
	if x, ok := m.GetRepr().(*Number_N); ok {
		return x.N
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Number) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _Number_OneofMarshaler, _Number_OneofUnmarshaler, _Number_OneofSizer, []interface{}{
		(*Number_N)(nil),
	}
}

func _Number_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*Number)
	// repr
	switch x := m.Repr.(type) {
	case *Number_N:
		b.EncodeVarint(1<<3 | proto1.WireFixed64)
		b.EncodeFixed64(math.Float64bits(x.N))
	case nil:
	default:
		return fmt.Errorf("Number.Repr has unexpected type %T", x)
	}
	return nil
}

func _Number_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*Number)
	switch tag {
	case 1: // repr.n
		if wire != proto1.WireFixed64 {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed64()
		m.Repr = &Number_N{math.Float64frombits(x)}
		return true, err
	default:
		return false, nil
	}
}

func _Number_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*Number)
	// repr
	switch x := m.Repr.(type) {
	case *Number_N:
		n += proto1.SizeVarint(1<<3 | proto1.WireFixed64)
		n += 8
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Tuple struct {
	Attrs map[string]*Value `protobuf:"bytes,1,rep,name=attrs" json:"attrs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Tuple) Reset()                    { *m = Tuple{} }
func (m *Tuple) String() string            { return proto1.CompactTextString(m) }
func (*Tuple) ProtoMessage()               {}
func (*Tuple) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Tuple) GetAttrs() map[string]*Value {
	if m != nil {
		return m.Attrs
	}
	return nil
}

type Set struct {
	// Types that are valid to be assigned to Repr:
	//	*Set_Values_
	//	*Set_Bool
	//	*Set_Array
	//	*Set_String_
	Repr isSet_Repr `protobuf_oneof:"repr"`
}

func (m *Set) Reset()                    { *m = Set{} }
func (m *Set) String() string            { return proto1.CompactTextString(m) }
func (*Set) ProtoMessage()               {}
func (*Set) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isSet_Repr interface {
	isSet_Repr()
}

type Set_Values_ struct {
	Values *Set_Values `protobuf:"bytes,1,opt,name=values,oneof"`
}
type Set_Bool struct {
	Bool bool `protobuf:"varint,2,opt,name=bool,oneof"`
}
type Set_Array struct {
	Array *Set_Values `protobuf:"bytes,3,opt,name=array,oneof"`
}
type Set_String_ struct {
	String_ string `protobuf:"bytes,4,opt,name=string,oneof"`
}

func (*Set_Values_) isSet_Repr() {}
func (*Set_Bool) isSet_Repr()    {}
func (*Set_Array) isSet_Repr()   {}
func (*Set_String_) isSet_Repr() {}

func (m *Set) GetRepr() isSet_Repr {
	if m != nil {
		return m.Repr
	}
	return nil
}

func (m *Set) GetValues() *Set_Values {
	if x, ok := m.GetRepr().(*Set_Values_); ok {
		return x.Values
	}
	return nil
}

func (m *Set) GetBool() bool {
	if x, ok := m.GetRepr().(*Set_Bool); ok {
		return x.Bool
	}
	return false
}

func (m *Set) GetArray() *Set_Values {
	if x, ok := m.GetRepr().(*Set_Array); ok {
		return x.Array
	}
	return nil
}

func (m *Set) GetString_() string {
	if x, ok := m.GetRepr().(*Set_String_); ok {
		return x.String_
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Set) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), func(msg proto1.Message) (n int), []interface{}) {
	return _Set_OneofMarshaler, _Set_OneofUnmarshaler, _Set_OneofSizer, []interface{}{
		(*Set_Values_)(nil),
		(*Set_Bool)(nil),
		(*Set_Array)(nil),
		(*Set_String_)(nil),
	}
}

func _Set_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*Set)
	// repr
	switch x := m.Repr.(type) {
	case *Set_Values_:
		b.EncodeVarint(1<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Values); err != nil {
			return err
		}
	case *Set_Bool:
		t := uint64(0)
		if x.Bool {
			t = 1
		}
		b.EncodeVarint(2<<3 | proto1.WireVarint)
		b.EncodeVarint(t)
	case *Set_Array:
		b.EncodeVarint(3<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Array); err != nil {
			return err
		}
	case *Set_String_:
		b.EncodeVarint(4<<3 | proto1.WireBytes)
		b.EncodeStringBytes(x.String_)
	case nil:
	default:
		return fmt.Errorf("Set.Repr has unexpected type %T", x)
	}
	return nil
}

func _Set_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*Set)
	switch tag {
	case 1: // repr.values
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Set_Values)
		err := b.DecodeMessage(msg)
		m.Repr = &Set_Values_{msg}
		return true, err
	case 2: // repr.bool
		if wire != proto1.WireVarint {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Repr = &Set_Bool{x != 0}
		return true, err
	case 3: // repr.array
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Set_Values)
		err := b.DecodeMessage(msg)
		m.Repr = &Set_Array{msg}
		return true, err
	case 4: // repr.string
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Repr = &Set_String_{x}
		return true, err
	default:
		return false, nil
	}
}

func _Set_OneofSizer(msg proto1.Message) (n int) {
	m := msg.(*Set)
	// repr
	switch x := m.Repr.(type) {
	case *Set_Values_:
		s := proto1.Size(x.Values)
		n += proto1.SizeVarint(1<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Set_Bool:
		n += proto1.SizeVarint(2<<3 | proto1.WireVarint)
		n += 1
	case *Set_Array:
		s := proto1.Size(x.Array)
		n += proto1.SizeVarint(3<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(s))
		n += s
	case *Set_String_:
		n += proto1.SizeVarint(4<<3 | proto1.WireBytes)
		n += proto1.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Set_Values struct {
	Value []*Value `protobuf:"bytes,1,rep,name=value" json:"value,omitempty"`
}

func (m *Set_Values) Reset()                    { *m = Set_Values{} }
func (m *Set_Values) String() string            { return proto1.CompactTextString(m) }
func (*Set_Values) ProtoMessage()               {}
func (*Set_Values) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *Set_Values) GetValue() []*Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func init() {
	proto1.RegisterType((*UpdateReq)(nil), "proto.UpdateReq")
	proto1.RegisterType((*UpdateAck)(nil), "proto.UpdateAck")
	proto1.RegisterType((*ObserveReq)(nil), "proto.ObserveReq")
	proto1.RegisterType((*ObserveResp)(nil), "proto.ObserveResp")
	proto1.RegisterType((*Value)(nil), "proto.Value")
	proto1.RegisterType((*Number)(nil), "proto.Number")
	proto1.RegisterType((*Tuple)(nil), "proto.Tuple")
	proto1.RegisterType((*Set)(nil), "proto.Set")
	proto1.RegisterType((*Set_Values)(nil), "proto.Set.Values")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Arrai service

type ArraiClient interface {
	Update(ctx context.Context, opts ...grpc.CallOption) (Arrai_UpdateClient, error)
	Observe(ctx context.Context, in *ObserveReq, opts ...grpc.CallOption) (Arrai_ObserveClient, error)
}

type arraiClient struct {
	cc *grpc.ClientConn
}

func NewArraiClient(cc *grpc.ClientConn) ArraiClient {
	return &arraiClient{cc}
}

func (c *arraiClient) Update(ctx context.Context, opts ...grpc.CallOption) (Arrai_UpdateClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Arrai_serviceDesc.Streams[0], c.cc, "/proto.Arrai/Update", opts...)
	if err != nil {
		return nil, err
	}
	x := &arraiUpdateClient{stream}
	return x, nil
}

type Arrai_UpdateClient interface {
	Send(*UpdateReq) error
	Recv() (*UpdateAck, error)
	grpc.ClientStream
}

type arraiUpdateClient struct {
	grpc.ClientStream
}

func (x *arraiUpdateClient) Send(m *UpdateReq) error {
	return x.ClientStream.SendMsg(m)
}

func (x *arraiUpdateClient) Recv() (*UpdateAck, error) {
	m := new(UpdateAck)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *arraiClient) Observe(ctx context.Context, in *ObserveReq, opts ...grpc.CallOption) (Arrai_ObserveClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Arrai_serviceDesc.Streams[1], c.cc, "/proto.Arrai/Observe", opts...)
	if err != nil {
		return nil, err
	}
	x := &arraiObserveClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Arrai_ObserveClient interface {
	Recv() (*ObserveResp, error)
	grpc.ClientStream
}

type arraiObserveClient struct {
	grpc.ClientStream
}

func (x *arraiObserveClient) Recv() (*ObserveResp, error) {
	m := new(ObserveResp)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Arrai service

type ArraiServer interface {
	Update(Arrai_UpdateServer) error
	Observe(*ObserveReq, Arrai_ObserveServer) error
}

func RegisterArraiServer(s *grpc.Server, srv ArraiServer) {
	s.RegisterService(&_Arrai_serviceDesc, srv)
}

func _Arrai_Update_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ArraiServer).Update(&arraiUpdateServer{stream})
}

type Arrai_UpdateServer interface {
	Send(*UpdateAck) error
	Recv() (*UpdateReq, error)
	grpc.ServerStream
}

type arraiUpdateServer struct {
	grpc.ServerStream
}

func (x *arraiUpdateServer) Send(m *UpdateAck) error {
	return x.ServerStream.SendMsg(m)
}

func (x *arraiUpdateServer) Recv() (*UpdateReq, error) {
	m := new(UpdateReq)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Arrai_Observe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ObserveReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ArraiServer).Observe(m, &arraiObserveServer{stream})
}

type Arrai_ObserveServer interface {
	Send(*ObserveResp) error
	grpc.ServerStream
}

type arraiObserveServer struct {
	grpc.ServerStream
}

func (x *arraiObserveServer) Send(m *ObserveResp) error {
	return x.ServerStream.SendMsg(m)
}

var _Arrai_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Arrai",
	HandlerType: (*ArraiServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Update",
			Handler:       _Arrai_Update_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Observe",
			Handler:       _Arrai_Observe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "arrai.proto",
}

func init() { proto1.RegisterFile("arrai.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 431 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x52, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0xf5, 0xc4, 0x99, 0xa1, 0xbd, 0x06, 0x54, 0xae, 0x90, 0xb0, 0xbc, 0x40, 0xd6, 0x08, 0x09,
	0x23, 0x20, 0x2a, 0x86, 0x05, 0x62, 0x97, 0xf2, 0x90, 0x57, 0x20, 0x4d, 0x81, 0xbd, 0x1d, 0x46,
	0x10, 0x9a, 0xda, 0xd3, 0x99, 0x49, 0x45, 0x36, 0x7c, 0x06, 0x3f, 0xc4, 0x8f, 0xa1, 0x79, 0x24,
	0x86, 0x2a, 0xac, 0xba, 0xb2, 0xe7, 0x9c, 0x73, 0x5f, 0x47, 0x07, 0xb2, 0x56, 0xeb, 0x76, 0x39,
	0x53, 0x7a, 0xb0, 0x03, 0x52, 0xff, 0xe1, 0xaf, 0xe1, 0xf0, 0x93, 0xfa, 0xd2, 0x5a, 0x29, 0xe4,
	0x05, 0x22, 0x4c, 0xe5, 0x0f, 0xa5, 0x73, 0x52, 0x92, 0xea, 0x50, 0xf8, 0x7f, 0xe4, 0x40, 0x55,
	0xab, 0xdb, 0xf3, 0x7c, 0x52, 0x92, 0x2a, 0xab, 0x6f, 0x86, 0xf2, 0xd9, 0xe7, 0x76, 0xb5, 0x96,
	0x22, 0x50, 0x3c, 0xdb, 0x36, 0x99, 0x2f, 0xce, 0xf8, 0x1b, 0x80, 0x0f, 0x9d, 0x91, 0xfa, 0xf2,
	0x5a, 0x2d, 0x9f, 0x41, 0xb6, 0xeb, 0x62, 0x94, 0x2b, 0xb9, 0x74, 0x74, 0x9e, 0xee, 0x2b, 0xf1,
	0x14, 0xff, 0x45, 0x80, 0x7a, 0x00, 0x1f, 0x02, 0xeb, 0xd7, 0xe7, 0x9d, 0x0c, 0x63, 0xb3, 0xfa,
	0x56, 0x94, 0xbf, 0xf7, 0x60, 0x93, 0x88, 0x48, 0xe3, 0x03, 0xa0, 0x76, 0xad, 0x56, 0xf2, 0xca,
	0x26, 0x1f, 0x1d, 0xd6, 0x24, 0x22, 0x90, 0x78, 0x1f, 0x52, 0x23, 0x6d, 0x1c, 0x0d, 0x51, 0x73,
	0x2a, 0x6d, 0x93, 0x08, 0x47, 0xe0, 0x5d, 0x98, 0x7e, 0x37, 0x43, 0x9f, 0x4f, 0xdd, 0x8d, 0x4d,
	0x22, 0xfc, 0xeb, 0xe4, 0x00, 0xd8, 0xe2, 0xdb, 0xb0, 0x5c, 0x48, 0x5e, 0x02, 0x0b, 0x93, 0xf1,
	0x36, 0x90, 0xde, 0xef, 0x44, 0x9a, 0x44, 0x90, 0xfe, 0x84, 0xc1, 0x54, 0x4b, 0xa5, 0xf9, 0x4f,
	0xa0, 0x7e, 0x26, 0x3e, 0x05, 0xda, 0x5a, 0xab, 0x4d, 0x4e, 0xca, 0xb4, 0xca, 0xea, 0x7b, 0x7f,
	0x2f, 0x34, 0x9b, 0x3b, 0xe6, 0x6d, 0x6f, 0xf5, 0x46, 0x04, 0x55, 0xf1, 0x0e, 0x60, 0x04, 0xf1,
	0x08, 0xd2, 0x33, 0xb9, 0x89, 0x56, 0xbb, 0xdf, 0xd1, 0xb6, 0xc9, 0x7f, 0x6d, 0x7b, 0x35, 0x79,
	0x49, 0xf8, 0x6f, 0x02, 0xe9, 0xa9, 0xb4, 0xf8, 0x18, 0x98, 0x07, 0x4d, 0x34, 0xee, 0xce, 0x78,
	0x6c, 0x28, 0x32, 0xce, 0xbc, 0x20, 0x71, 0x67, 0x77, 0xc3, 0xb0, 0xf2, 0xbd, 0x0f, 0xdc, 0xd9,
	0xee, 0x85, 0x8f, 0x80, 0xba, 0x98, 0x6d, 0xa2, 0x5d, 0x7b, 0x3b, 0x04, 0x05, 0xe6, 0xc0, 0x8c,
	0xd5, 0xcb, 0xfe, 0xeb, 0xce, 0xb9, 0xf8, 0x2e, 0x9e, 0x00, 0x0b, 0xe2, 0xf1, 0x82, 0x60, 0xc8,
	0xbe, 0x0b, 0xb6, 0x2e, 0xd6, 0x17, 0x40, 0xe7, 0x2e, 0xe1, 0x58, 0x03, 0x0b, 0x79, 0xc4, 0xa3,
	0xa8, 0xdf, 0x65, 0xbc, 0xf8, 0x17, 0x71, 0x81, 0x4d, 0x2a, 0x72, 0x4c, 0xf0, 0x05, 0xdc, 0x88,
	0x81, 0xc3, 0xed, 0xce, 0x63, 0x8c, 0x0b, 0xbc, 0x0a, 0x19, 0xc5, 0x93, 0x63, 0xd2, 0x31, 0x0f,
	0x3f, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0xcf, 0xfa, 0x87, 0x4e, 0x5b, 0x03, 0x00, 0x00,
}
